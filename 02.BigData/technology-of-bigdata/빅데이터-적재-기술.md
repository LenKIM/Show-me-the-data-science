# 빅데이터 적재.

수집한 데이터는 데이터의 성격에 따라 처리 방식과 적재 위치가 달라질 수 있다.   

크게는 데이터 발생 주기에 따라 일괄 배치성 데이터인지, 실시간 스트림 데이터인지를 판단해야 하고,  

데이터의 형식에 따라 가공처리나 사전 검증 작업을 할 것인지도 판단해야 한다.



적제한 데이터를 어떤 비즈니스 요건에서 활용하느냐에 따라 적재 대상 위치가 달라질 수도 있는데, 이는 데이터 적재 후 데이터 분석 방식과 데이터 활용성 및 업무 시스템의 성격에 따라 적제 저장소가 분산 파일, NoSQL, 메모리 캐시 등으로 달리 구성돼야 함을 의미.



![](https://ws1.sinaimg.cn/large/006tNc79gy1g208i4v8dij31ep0u0e82.jpg)



---

## 하둡



하둡은 크게 두 가지 기능이 있는데, 첫 번째가 대용량 데이터를 분산 저장하는 것이고, 두 번째는 분산 저장된 대용량 데이터를 분석하는 기능. 이 가운데 대용량 데이터 처리를 위해 분산 병렬 처리 기술을 사용하는데, 분산 컴퓨팅 기술은 하둡이 처음.



- 주요 구성 요소
  - **DataNode** - 블록(64MB or 128MB 등) 단위로 분할된 대용량 파일들이 DataNode의 디스크에 저장 및 관리
  - **NameNode** - DataNode에 저장된 파일들의 메타 정보를 메모리상에서 로드해서 관리
  - **EditLog** - 파일들의 변경 이력(수정, 삭제 등) 정보가 저장되는 로그 파일
  - **FsImage** - NameNode의 메모리상에 올라와 있는 메타 정보를 스냅샵 이미지로 만들어 생성한 파일
  - Ver. 1.x
    - SecondaryNameNode - NameNode의 FsImage와 EditLog파일을 주기적으로 유지해주는체크포인팅 노드
    - MapReduce v1 - DataNode에 분산 저장된 파일이 스플릿(Map)되어 다양한 연산(정렬, 그루핑, 집계 등)을 수행한 뒤 그 결과를 다시 병합(Reduce)하는 분산 프로그래밍 기법
    - JobTracker - 맵리듀스의 잡을 실행하면서 태스크를 할당하고, 전체 잡에 대해 리소스 분배 및 스케줄링
    - TaskTracker - JobTracker가 요청한 맵리듀스 프로그램이 실행되는 테스크이며, 이때 맵 태스크와 리듀스 태스크가 생성
  - Ver. 2.x
    - Active/Stand-by nameNode - NameNode를 이중화해서 서비스 중인 Active NameNode와 실패처리를 대비한 Standby NameNode로 구성
    - MapReduce v2 / YARN - 하둡 클러스터 내의 자원을 중앙 관리하고, 그 위에 다양한 애플리케이션을 실행 및 관리가 가능하도록 확장성과 호환성을 높인 하둡 2.x의 플랫폼
    - ResourceManager - 하둡 클러스터 내의 자원을 중앙 관리하면서, 작업 요청 시 스케줄링 정책에 따라 자원을 배분해서 실행시키고 모니터링
    - NodeManager - 하둡 클러스터의 DataNode마다 실행되면서 Container를 실행시키고 라이프 사이클을 관리.
    - Container - DataNode의 사용가능한 리소스(CPU, 메모리, 디스크 등)를 Container단위로 할당해서 구성
    - ApplicationMaster - 애플리케이션 실행되면 Applicationmaster가 생성되며 Applicationmaster는 NodeManager에게 애플리케이션이 실행될 Container를 요청하고,  그 위에서 애플리케이션을 실행 및 관리
    - JournalNode - 3개 이상의 노드로 구성되어 EditsLog를 각 노드에 복제 관리하며 Active NameNode는 EditsLog에 쓰기만을 수행하고 Standby NameNode는 읽기만을 실행



![](https://ws1.sinaimg.cn/large/006tNc79gy1g20966tx3dj31550u07wi.jpg)

![](https://ws1.sinaimg.cn/large/006tNc79gy1g2096j07mij31150u0e82.jpg)



## 주키퍼

수십- 수천 대의 서버에 설치돼 있는 빅데이터 분산 환경을 더욱 효율적으로 관리하기 위해서는 서버 간의 정보를 쉽고 안전하게 공유해야 한다. 공유된 정보를 이용해 서버 간의 중요한 이벤트(분산락, 순서제어, 부하 분산, 네임서비스 등)를 관리하면서 상호작용을 조율해 주는 코디네이터 시스템이 필요한데, 이것이 바로 분산 코디네이터인 아파치 주키퍼(Apache Zookeeper)다.

***분산 노드 관리***



- 주요 구성 요소

  - Client - 주키퍼의 ZNode에 담긴 데이터에 대한 쓰기, 읽기, 삭제 등의 작업을 요청하는 클라이언트

- 주요 구성 요소

  - ZNode - 주키퍼 서버에 생성되는 파일시스템의 디렉토리 개념으로,클라이언트의 요청 정보를 계층적으로 관리(버전, 접근 권한, 상태, 모니터링 객체 관리 등의 기능 지원)
  - Ensemble - 3대 이상의 주키퍼 서버를 하나의 클러스터로 구성한 HA 클러스터
  - Leader Server - Ensemble안에는 유일한 리더 서버가 선출되어 존재하며, 클라이언트의 요청을 받은 서버는 해당 요청을 리더 서버에 전달하고, 리더 서버는 모든 팔로워 서버에게 클라이언트 요청이 전달되도록 보장.
  - Follower Server - Ensemble안에서 한 대의 리더 서버를 제외한 나머지 서버로서, 리더 서버와 메시지를 주고받으면서 ZNode의 데이터를 동기화하고 리더 서버에 문제가 발생할 경우 내부적으로 새로운 리더를 선출하는 역할을 수행.

  

주키퍼는 3대 이상의 홀수 개의 서버로 구성돼야 하며, 그중 반드시 1대는 리더(Leader)서버가 되고 나머지 서버는 팔로워(Follower)서버가 된다. 그림 4.7을 보면 팔로워 서버 1에 저장된 ZNode정보는 리더 서버에 전달되고, 리더 서버는 다른 모든 팔로워 서버에 요청받은 ZNode정보를 브로드캐스트한다.

![](https://ws4.sinaimg.cn/large/006tNc79gy1g209hej5paj31du0u07wi.jpg)

